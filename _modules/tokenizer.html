

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>tokenizer &mdash; textTinyPy documentation 0.0.1 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../genindex.html"/>
        <link rel="search" title="Search" href="../search.html"/>
    <link rel="top" title="textTinyPy documentation 0.0.1 documentation" href="../index.html"/>
        <link rel="up" title="Module code" href="index.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> textTinyPy documentation
          

          
          </a>

          
            
            
              <div class="version">
                0.0.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul>
<li class="toctree-l1"><a class="reference internal" href="../page.html"><strong>Text Processing Functions for Small or Big Data Files in Python</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="../modules.html"><strong>textTinyPy classes</strong></a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../index.html">textTinyPy documentation</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          





<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../index.html">Docs</a> &raquo;</li>
      
          <li><a href="index.html">Module code</a> &raquo;</li>
      
    <li>tokenizer</li>
      <li class="wy-breadcrumbs-aside">
        
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for tokenizer</h1><div class="highlight"><pre>
<span></span>


<span class="kn">import</span> <span class="nn">sys</span>
<span class="n">py_version</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span>
<span class="k">if</span> <span class="n">py_version</span><span class="o">.</span><span class="n">major</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
    <span class="n">MAX_VAL</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">maxint</span>         <span class="c1"># python 2 maximum integer</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">MAX_VAL</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">maxsize</span>        <span class="c1"># python 3 maximum integer</span>



<div class="viewcode-block" id="tokenizer"><a class="viewcode-back" href="../_autosummary/tokenizer.html#tokenizer.tokenizer">[docs]</a><span class="k">class</span> <span class="nc">tokenizer</span><span class="p">:</span>
    
    
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    </span>
<span class="sd">    String tokenization and transformation</span>
<span class="sd">    </span>
<span class="sd">        </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
<span class="c1">#    cdef big_files* bgf</span>
<span class="c1">#    </span>
<span class="c1">#    cdef BATCH_TOKEN* btk</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1">#    def __cinit__(self):</span>
<span class="c1">#               </span>
<span class="c1">#        self.bgf = new big_files()</span>
<span class="c1">#        </span>
<span class="c1">#        self.btk = new BATCH_TOKEN()</span>
<span class="c1">#        </span>
<span class="c1">#</span>
<span class="c1">#    def __dealloc__(self):</span>
<span class="c1">#        </span>
<span class="c1">#        del self.bgf</span>
<span class="c1">#        </span>
<span class="c1">#        del self.btk  </span>
 
    
    
    
<div class="viewcode-block" id="tokenizer.transform_text"><a class="viewcode-back" href="../_autosummary/tokenizer.html#tokenizer.tokenizer.transform_text">[docs]</a>    <span class="k">def</span> <span class="nf">transform_text</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_string</span><span class="p">,</span> <span class="n">batches</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">read_file_delimiter</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">LOCALE_UTF</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">to_lower</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">to_upper</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">language</span> <span class="o">=</span> <span class="s1">&#39;english&#39;</span><span class="p">,</span>
                  
                      <span class="n">REMOVE_characters</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">remove_punctuation_string</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">remove_numbers</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">trim_token</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">split_string</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> 
                      
                      <span class="n">separator</span> <span class="o">=</span> <span class="s2">&quot; </span><span class="se">\r\n\t</span><span class="s2">.,;:()?!//&quot;</span><span class="p">,</span> <span class="n">remove_punctuation_vector</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">remove_stopwords</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">min_num_char</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">max_num_char</span> <span class="o">=</span> <span class="n">MAX_VAL</span><span class="p">,</span> 
    
                      <span class="n">stemmer</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">min_n_gram</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">max_n_gram</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_gram_delimiter</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="n">skip_n_gram</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">skip_distance</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">stemmer_ngram</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> 
                      
                      <span class="n">stemmer_gamma</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">stemmer_truncate</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">stemmer_batches</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">vocabulary_path</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">concat_delimiter</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">path_2folder</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
                      
                      <span class="n">threads</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>

        
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        </span>
<span class="sd">        :param input_string: either a character string of length 1 or a character-string-path to a file (for big .txt files it&#39;s recommended to use a path to a file)</span>
<span class="sd">        </span>
<span class="sd">        :param batches: a numeric value. If the batches parameter is not None then the object parameter should be a valid path to a file and the path_2folder parameter should be a valid path to a folder. The batches parameter should be used in case of small to medium data sets (for zero memory consumption). For big data sets the big_tokenize_transform class and especially the big_text_tokenizer method should be used.</span>
<span class="sd">        </span>
<span class="sd">        :param read_file_delimiter: the delimiter to use when the input file will be red (for instance a tab-delimiter or a new-line delimiter).</span>
<span class="sd">        </span>
<span class="sd">        :param LOCALE_UTF: the language specific locale to use in case that either the to_lower or the to_upper parameter is TRUE and the text file language is other than english. For instance if the language of a text file is greek then the utf_locale parameter should be &#39;el_GR.UTF-8&#39; ( language_country.encoding ). A wrong utf-locale does not raise an error, however the runtime of the method increases.</span>
<span class="sd">        </span>
<span class="sd">        :param to_lower: either True or False. If True the character string will be converted to lower case</span>
<span class="sd">        </span>
<span class="sd">        :param to_upper: either True or False. If True the character string will be converted to upper case</span>
<span class="sd">        </span>
<span class="sd">        :param language: a character string which defaults to english. If the remove_stopwords parameter is True then the corresponding stop words vector will be uploaded. Available languages &#39;afrikaans&#39;, </span>
<span class="sd">        </span>
<span class="sd">            &#39;arabic&#39;, &#39;armenian&#39;, &#39;basque&#39;, &#39;bengali&#39;, &#39;breton&#39;, &#39;bulgarian&#39;, &#39;catalan&#39;, &#39;croatian&#39;, &#39;czech&#39;,&#39;danish&#39;, &#39;dutch&#39;, &#39;english&#39;, &#39;estonian&#39;, &#39;finnish&#39;, &#39;french&#39;, &#39;galician&#39;, &#39;german&#39;, </span>
<span class="sd">            &#39;greek&#39;, &#39;hausa&#39;, &#39;hebrew&#39;, &#39;hindi&#39;, &#39;hungarian&#39;, &#39;indonesian&#39;, &#39;irish&#39;, &#39;italian&#39;, &#39;latvian&#39;, &#39;marathi&#39;, &#39;norwegian&#39;, &#39;persian&#39;, &#39;polish&#39;, &#39;portuguese&#39;, &#39;romanian&#39;, &#39;russian&#39;,</span>
<span class="sd">            &#39;slovak&#39;, &#39;slovenian&#39;, &#39;somalia&#39;, &#39;spanish&#39;, &#39;swahili&#39;, &#39;swedish&#39;, &#39;turkish&#39;, &#39;yoruba&#39;, &#39;zulu&#39;</span>

<span class="sd">        :param REMOVE_characters: a character string with specific characters that should be removed from the text file. If the remove_char is &quot;&quot; then no removal of characters take place</span>
<span class="sd">        </span>
<span class="sd">        :param remove_punctuation_string: either True or False. If True then the punctuation of the character string will be removed (applies before the split method)</span>
<span class="sd">        </span>
<span class="sd">        :param remove_numbers: either True or False. If True then any numbers in the character string will be removed</span>
<span class="sd">        </span>
<span class="sd">        :param trim_token: either True or False. If True then the string will be trimmed (left and/or right)</span>
<span class="sd">        </span>
<span class="sd">        :param split_string: either True or False. If True then the character string will be split using the separator as delimiter. The user can also specify multiple delimiters.</span>
<span class="sd">        </span>
<span class="sd">        :param separator: a character string specifying the character delimiter(s)</span>
<span class="sd">        </span>
<span class="sd">        :param remove_punctuation_vector: either True or False. If True then the punctuation of the vector of the character strings will be removed  (after the string split has taken place)</span>
<span class="sd">    </span>
<span class="sd">        :param remove_stopwords: either True, False or a character vector of user defined stop words. If True then by using the language parameter the corresponding stop words vector will be uploaded.</span>

<span class="sd">        :param min_num_char: an integer specifying the minimum number of characters to keep. If the min_num_char is greater than 1 then character strings with more than 1 characters will be returned</span>
<span class="sd">        </span>
<span class="sd">        :param max_num_char: an integer specifying the maximum number of characters to keep. The max_num_char should be less than or equal to Inf (in this method the Inf value translates to a word-length of 1000000000)</span>

<span class="sd">        :param stemmer: a character string specifying the stemming method. One of the following porter2_stemmer, ngram_sequential, ngram_overlap. </span>

<span class="sd">        :param min_n_gram: an integer specifying the minimum number of n-grams. The minimum number of min_n_gram is 1.</span>
<span class="sd">        </span>
<span class="sd">        :param max_n_gram: an integer specifying the maximum number of n-grams. The minimum number of max_n_gram is 1.</span>
<span class="sd">        </span>
<span class="sd">        :param n_gram_delimiter: a character string specifying the n-gram delimiter (applies to both n-gram and skip-n-gram cases)</span>
<span class="sd">        </span>
<span class="sd">        :param skip_n_gram: an integer specifying the number of skip-n-grams. The minimum number of skip_n_gram is 1.</span>
<span class="sd">        </span>
<span class="sd">        :param skip_distance: an integer specifying the skip distance between the words. The minimum value for the skip distance is 0, in which case simple n-grams will be returned.</span>
<span class="sd">        </span>
<span class="sd">        :param stemmer_ngram: a numeric value greater than 1. Applies to both ngram_sequential and ngram_overlap methods. In case of ngram_sequential the first n characters will be picked, whereas in the case of ngram_overlap the overlapping stemmer_ngram characters will be build.</span>
<span class="sd">        </span>
<span class="sd">        :param stemmer_gamma: a float number greater or equal to 0.0. Applies only to ngram_sequential. Is a threshold value, which defines how much frequency deviation of two N-grams is acceptable. It is kept either zero or to a minimum value.</span>
<span class="sd">        </span>
<span class="sd">        :param stemmer_truncate: a numeric value greater than 0. Applies only to ngram_sequential. The ngram_sequential is modified to use relative frequencies (float numbers between 0.0 and 1.0 for the ngrams of a specific word in the corpus) and the stemmer_truncate parameter controls the number of rounding digits for the ngrams of the word. The main purpose was to give the same relative frequency to words appearing approximately the same on the corpus.</span>

<span class="sd">        :param stemmer_batches: a numeric value greater than 0. Applies only to ngram_sequential. Splits the corpus into batches with the option to run the batches in multiple threads.</span>
<span class="sd">        </span>
<span class="sd">        :param vocabulary_path_file: either None or a character string specifying the output path to a file where the vocabulary should be saved once the text is tokenized</span>
<span class="sd">        </span>
<span class="sd">        :param concat_delimiter: either None or a character string specifying the delimiter to use in order to concatenate the end-vector of character strings to a single character string (recommended in case that the end-vector should be saved to a file)</span>
<span class="sd">        </span>
<span class="sd">        :param path_2folder: a character string specifying the path to the folder where the file(s) will be saved</span>
<span class="sd">        </span>
<span class="sd">        :param threads: an integer specifying the number of cores to run in parallel</span>
<span class="sd">        </span>
<span class="sd">        :param verbose: either True or False. If True then information will be printed out</span>
<span class="sd">        </span>
<span class="sd">            Example::</span>
<span class="sd">                </span>
<span class="sd">                tok = tokenizer()</span>
<span class="sd">                </span>
<span class="sd">                res_tok = tok.transform_text(input_string = &#39;/myfolder/file_text.txt&#39;, to_lower = True, trim_token = True, split_string = True)</span>

<span class="sd">        </span>
<span class="sd">        &#39;&#39;&#39;</span>
                
        
<span class="c1">#        cdef vector[string] result_vec</span>
<span class="c1">#        </span>
<span class="c1">#        assert isinstance(input_string, basestring), &#39;the input_string parameter should be of type string&#39;             </span>
<span class="c1">#        </span>
<span class="c1">#        FLAG_path = False</span>
<span class="c1">#        </span>
<span class="c1">#        if os.path.exists(input_string):</span>
<span class="c1">#            </span>
<span class="c1">#            FLAG_path = True </span>
<span class="c1">#        </span>
<span class="c1">#        #--------------------</span>
<span class="c1">#        # exception handling        </span>
<span class="c1">#        #--------------------</span>
<span class="c1">#        </span>
<span class="c1">#        assert isinstance(path_2folder, basestring), &#39;the path_2folder parameter should be of type string&#39;</span>
<span class="c1">#</span>
<span class="c1">#        IF UNAME_SYSNAME == &quot;Windows&quot;:</span>
<span class="c1">#            </span>
<span class="c1">#            assert path_2folder.split(&#39;\\&#39;)[-1] == &quot;&quot;, &quot;the path_2folder parameter should end in slash&quot;</span>
<span class="c1">#            </span>
<span class="c1">#        IF UNAME_SYSNAME == &quot;Darwin&quot; or UNAME_SYSNAME == &quot;Linux&quot;:</span>
<span class="c1">#            </span>
<span class="c1">#            assert path_2folder.split(&#39;/&#39;)[-1] == &quot;&quot;, &quot;the path_2folder parameter should end in slash&quot;</span>
<span class="c1">#            </span>
<span class="c1">#        if batches is not None:</span>
<span class="c1">#            </span>
<span class="c1">#            assert isinstance(batches, int) and batches &gt; 1, &#39;the batches parameter should be of type integer and greater than 1&#39;</span>
<span class="c1">#            </span>
<span class="c1">#            assert path_2folder != &quot;&quot;, &quot;give the path to a valid folder in case that the batches parameter is not None&quot;</span>
<span class="c1">#            </span>
<span class="c1">#            if not FLAG_path:</span>
<span class="c1">#                </span>
<span class="c1">#                raise_with_traceback(ValueError(&#39;in case that the batches parameter is not None the input_string parameter should be a valid path to a file&#39;))</span>
<span class="c1">#        </span>
<span class="c1">#        assert isinstance(read_file_delimiter, basestring), &#39;the read_file_delimiter parameter should be of type string&#39;</span>
<span class="c1">#        </span>
<span class="c1">#        assert len(read_file_delimiter) == 1, &#39;the read_file_delimiter should be a single character string&#39;</span>
<span class="c1">#            </span>
<span class="c1">#        assert isinstance(LOCALE_UTF, basestring), &#39;the LOCALE_UTF parameter should be of type string&#39;</span>
<span class="c1">#            </span>
<span class="c1">#        assert isinstance(to_lower, bool), &#39;the to_lower parameter should be of type boolean&#39;</span>
<span class="c1">#            </span>
<span class="c1">#        assert isinstance(to_upper, bool), &#39;the to_upper parameter should be of type boolean&#39;</span>
<span class="c1">#                </span>
<span class="c1">#        assert isinstance(REMOVE_characters, basestring), &#39;the REMOVE_characters parameter should be of type string&#39;</span>
<span class="c1">#            </span>
<span class="c1">#        assert isinstance(remove_punctuation_string, bool), &#39;the remove_punctuation_string parameter should be of type boolean&#39;</span>
<span class="c1">#            </span>
<span class="c1">#        assert isinstance(remove_numbers, bool), &#39;the remove_numbers parameter should be of type boolean&#39;</span>
<span class="c1">#            </span>
<span class="c1">#        assert isinstance(trim_token, bool), &#39;the trim_token parameter should be of type boolean&#39;</span>
<span class="c1">#            </span>
<span class="c1">#        assert isinstance(split_string, bool), &#39;the split_string parameter should be of type boolean&#39;</span>
<span class="c1">#            </span>
<span class="c1">#        assert isinstance(separator, basestring), &#39;the separator parameter should be of type string&#39;</span>
<span class="c1">#            </span>
<span class="c1">#        assert isinstance(remove_punctuation_vector, bool), &#39;the remove_punctuation_vector parameter should be of type boolean&#39;</span>
<span class="c1">#        </span>
<span class="c1">#        assert isinstance(language, basestring), &#39;the language parameter should be of type string&#39;</span>
<span class="c1">#        </span>
<span class="c1">#        assert language in [&quot;afrikaans&quot;, &quot;arabic&quot;, &quot;armenian&quot;, &quot;basque&quot;, &quot;bengali&quot;, &quot;breton&quot;, &quot;bulgarian&quot;, &quot;catalan&quot;, &quot;croatian&quot;, &quot;czech&quot;, &quot;danish&quot;, &quot;dutch&quot;, &quot;english&quot;, </span>
<span class="c1">#                            &quot;estonian&quot;, &quot;finnish&quot;, &quot;french&quot;,&quot;galician&quot;, &quot;german&quot;, &quot;greek&quot;, &quot;hausa&quot;, &quot;hebrew&quot;, &quot;hindi&quot;, &quot;hungarian&quot;, &quot;indonesian&quot;, &quot;irish&quot;, &quot;italian&quot;, </span>
<span class="c1">#                            &quot;latvian&quot;, &quot;marathi&quot;, &quot;norwegian&quot;, &quot;persian&quot;, &quot;polish&quot;, &quot;portuguese&quot;, &quot;romanian&quot;, &quot;russian&quot;, &quot;slovak&quot;, &quot;slovenian&quot;, &quot;somalia&quot;, &quot;spanish&quot;, </span>
<span class="c1">#                            &quot;swahili&quot;, &quot;swedish&quot;, &quot;turkish&quot;, &quot;yoruba&quot;, &quot;zulu&quot;], &quot;available languages in case of stop-word removal are &#39;afrikaans&#39;, &#39;arabic&#39;, &#39;armenian&#39;,\</span>
<span class="c1">#                                                                                &#39;basque&#39;, &#39;bengali&#39;, &#39;breton&#39;, &#39;bulgarian&#39;, &#39;catalan&#39;, &#39;croatian&#39;, &#39;czech&#39;,&#39;danish&#39;, &#39;dutch&#39;,\</span>
<span class="c1">#                                                                                &#39;english&#39;, &#39;estonian&#39;, &#39;finnish&#39;, &#39;french&#39;, &#39;galician&#39;, &#39;german&#39;, &#39;greek&#39;, &#39;hausa&#39;, &#39;hebrew&#39;,\</span>
<span class="c1">#                                                                                &#39;hindi&#39;, &#39;hungarian&#39;, &#39;indonesian&#39;, &#39;irish&#39;, &#39;italian&#39;, &#39;latvian&#39;, &#39;marathi&#39;, &#39;norwegian&#39;,\</span>
<span class="c1">#                                                                                &#39;persian&#39;, &#39;polish&#39;, &#39;portuguese&#39;, &#39;romanian&#39;, &#39;russian&#39;, &#39;slovak&#39;, &#39;slovenian&#39;, &#39;somalia&#39;,\</span>
<span class="c1">#                                                                                &#39;spanish&#39;, &#39;swahili&#39;, &#39;swedish&#39;, &#39;turkish&#39;, &#39;yoruba&#39;, &#39;zulu. \</span>
<span class="c1">#                                                                                \</span>
<span class="c1">#                                                                                A user defined character list of stop words can be used as input, if the target language is not included&quot;</span>
<span class="c1">#        </span>
<span class="c1">#        if isinstance(remove_stopwords, bool):</span>
<span class="c1">#            </span>
<span class="c1">#            if remove_stopwords:</span>
<span class="c1">#                </span>
<span class="c1">#                IF UNAME_SYSNAME == &quot;Windows&quot;:</span>
<span class="c1">#                    </span>
<span class="c1">#                    resource_path = &#39;\\&#39;.join((&#39;stopwords&#39;, language + &#39;.txt&#39;))</span>
<span class="c1">#                    </span>
<span class="c1">#                ELSE:</span>
<span class="c1">#                    </span>
<span class="c1">#                    resource_path = &#39;/&#39;.join((&#39;stopwords&#39;, language + &#39;.txt&#39;))</span>
<span class="c1">#                    </span>
<span class="c1">#                path_stopw = pkg_resources.resource_filename(&#39;textTinyPy&#39;, resource_path)</span>
<span class="c1">#                </span>
<span class="c1">#                dat_stopw = pd.read_csv(path_stopw, header = None)</span>
<span class="c1">#                </span>
<span class="c1">#                array_stopw = np.array(dat_stopw.as_matrix(columns=None))</span>
<span class="c1">#                </span>
<span class="c1">#                list_stopw = [i[0] for i in array_stopw]</span>
<span class="c1">#                </span>
<span class="c1">#                list_stopw.append(&quot;&quot;)</span>
<span class="c1">#                </span>
<span class="c1">#            else:</span>
<span class="c1">#                </span>
<span class="c1">#                list_stopw = []</span>
<span class="c1">#        </span>
<span class="c1">#        elif isinstance(remove_stopwords, list):</span>
<span class="c1">#            </span>
<span class="c1">#            list_stopw = remove_stopwords</span>
<span class="c1">#            </span>
<span class="c1">#            remove_stopwords = True</span>
<span class="c1">#            </span>
<span class="c1">#        else:</span>
<span class="c1">#            </span>
<span class="c1">#            raise_with_traceback(ValueError(&quot;the remove_stopwords parameter should be either a list of user defined stopwords or a logical parameter ( True or False )&quot;))</span>
<span class="c1">#            </span>
<span class="c1">#        assert isinstance(min_num_char, int) and min_num_char &gt; 0, &#39;the min_num_char parameter should be of type integer and greater than 0&#39;</span>
<span class="c1">#            </span>
<span class="c1">#        assert isinstance(max_num_char, int) and max_num_char &gt; min_num_char, &#39;the max_num_char parameter should be of type integer and greater than the min_num_char&#39;</span>
<span class="c1">#        </span>
<span class="c1">#        if max_num_char == MAX_VAL:</span>
<span class="c1">#            </span>
<span class="c1">#            max_num_char = 1000000000</span>
<span class="c1">#        </span>
<span class="c1">#        if stemmer is not None:</span>
<span class="c1">#            </span>
<span class="c1">#            assert isinstance(stemmer, basestring), &#39;the stemmer parameter should be of type string&#39;</span>
<span class="c1">#            </span>
<span class="c1">#            assert stemmer in [&quot;porter2_stemmer&quot;, &quot;ngram_sequential&quot;, &quot;ngram_overlap&quot;], &#39;available stemmers are : porter2_stemmer, ngram_sequential or ngram_overlap&#39;</span>
<span class="c1">#                </span>
<span class="c1">#        if stemmer is None:</span>
<span class="c1">#            </span>
<span class="c1">#            stemmer = &quot;NULL&quot;</span>
<span class="c1">#            </span>
<span class="c1">#        assert isinstance(min_n_gram, int) and min_n_gram &gt; 0, &#39;the min_n_gram parameter should be of type integer and greater than 0&#39;</span>
<span class="c1">#        </span>
<span class="c1">#        assert isinstance(max_n_gram, int) and max_n_gram &gt; 0, &#39;the max_n_gram parameter should be of type integer and greater than 0&#39;</span>
<span class="c1">#            </span>
<span class="c1">#        assert max_n_gram &gt;= min_n_gram, &#39;the max_n_gram parameter should be greater than the min_n_gram&#39;</span>
<span class="c1">#        </span>
<span class="c1">#        assert isinstance(n_gram_delimiter, basestring), &#39;the n_gram_delimiter parameter should be of type string&#39;</span>
<span class="c1">#                  </span>
<span class="c1">#        assert isinstance(skip_n_gram, int) and skip_n_gram &gt; 0, &#39;the skip_n_gram parameter should be of type integer and greater than 0&#39;</span>
<span class="c1">#            </span>
<span class="c1">#        assert isinstance(skip_distance, int) and skip_distance &gt; -1, &#39;the skip_distance parameter should be of type integer and greater or equal to 0&#39;</span>
<span class="c1">#        </span>
<span class="c1">#        if stemmer is not None:</span>
<span class="c1">#            </span>
<span class="c1">#            if stemmer == &quot;ngram_sequential&quot;:</span>
<span class="c1">#                </span>
<span class="c1">#                assert isinstance(stemmer_ngram, int) and stemmer_ngram &gt; 0, &#39;the stemmer_ngram parameter should be of type integer and greater than 0&#39;</span>
<span class="c1">#            </span>
<span class="c1">#                assert isinstance(stemmer_gamma, float) and stemmer_gamma &gt;= 0.0, &#39;the stemmer_gamma parameter should be of type float and greater or equal to 0.0&#39;</span>
<span class="c1">#                    </span>
<span class="c1">#                assert isinstance(stemmer_truncate, int) and stemmer_truncate &gt; 0, &#39;the stemmer_truncate parameter should be of type integer and greater than 0&#39;</span>
<span class="c1">#                    </span>
<span class="c1">#                assert isinstance(stemmer_batches, int) and stemmer_batches &gt; 0, &#39;the stemmer_batches parameter should be of type integer and greater than 0&#39;</span>
<span class="c1">#                </span>
<span class="c1">#            if stemmer == &quot;ngram_overlap&quot;:</span>
<span class="c1">#                </span>
<span class="c1">#                assert isinstance(stemmer_ngram, int) and stemmer_ngram &gt; 0, &#39;the stemmer_ngram parameter should be of type integer and greater than 0&#39;</span>
<span class="c1">#        </span>
<span class="c1">#        if vocabulary_path is not None:        </span>
<span class="c1">#        </span>
<span class="c1">#            assert isinstance(vocabulary_path, basestring), &#39;the vocabulary_path parameter should be of type string&#39;</span>
<span class="c1">#        </span>
<span class="c1">#        if vocabulary_path is None:</span>
<span class="c1">#            </span>
<span class="c1">#            vocabulary_path = &quot;&quot;</span>
<span class="c1">#            </span>
<span class="c1">#        assert isinstance(save_2single_file, bool), &#39;the save_2single_file parameter should be of type boolean&#39;</span>
<span class="c1">#            </span>
<span class="c1">#        if concat_delimiter is not None:</span>
<span class="c1">#            </span>
<span class="c1">#            assert isinstance(concat_delimiter, basestring), &#39;the concat_delimiter parameter should be of type string&#39;</span>
<span class="c1">#            </span>
<span class="c1">#        else:</span>
<span class="c1">#            </span>
<span class="c1">#            concat_delimiter = &quot;NULL&quot;</span>
<span class="c1">#        </span>
<span class="c1">#        assert isinstance(threads, int) and threads &gt; 0, &#39;the threads parameter should be of type integer and greater than 0&#39;</span>
<span class="c1">#            </span>
<span class="c1">#        assert isinstance(verbose, bool), &#39;the verbose parameter should be of type boolean&#39;</span>
<span class="c1">#        </span>
<span class="c1">#        </span>
<span class="c1">#        #----------</span>
<span class="c1">#        # function        </span>
<span class="c1">#        #----------        </span>
<span class="c1">#        </span>
<span class="c1">#        if batches is None:        </span>
<span class="c1">#        </span>
<span class="c1">#            result_vec = self.bgf.res_TOKEN(input_string, list_stopw, language, LOCALE_UTF, FLAG_path, read_file_delimiter, max_num_char, REMOVE_characters, </span>
<span class="c1">#                                             </span>
<span class="c1">#                                             to_lower, to_upper, remove_punctuation_string, remove_punctuation_vector, remove_numbers, trim_token, split_string, </span>
<span class="c1">#                                             </span>
<span class="c1">#                                             separator, remove_stopwords, min_num_char, stemmer, min_n_gram, max_n_gram, skip_n_gram, skip_distance, n_gram_delimiter, </span>
<span class="c1">#                                             </span>
<span class="c1">#                                              concat_delimiter, path_2folder, stemmer_ngram, stemmer_gamma, stemmer_truncate, stemmer_batches, threads, verbose, </span>
<span class="c1">#                                              </span>
<span class="c1">#                                              save_2single_file, &quot;output_token.txt&quot;, vocabulary_path)</span>
<span class="c1">#            </span>
<span class="c1">#            return result_vec</span>
<span class="c1">#            </span>
<span class="c1">#        else:</span>
<span class="c1">#            </span>
<span class="c1">#            if concat_delimiter == &quot;NULL&quot;:</span>
<span class="c1">#                </span>
<span class="c1">#                concat_delimiter = &quot;\n&quot;</span>
<span class="c1">#            </span>
<span class="c1">#            self.btk.batch_2file(input_string, path_2folder, batches, read_file_delimiter, list_stopw, language, LOCALE_UTF, max_num_char, REMOVE_characters, to_lower, </span>
<span class="c1">#                                       </span>
<span class="c1">#                                 to_upper, remove_punctuation_string, remove_punctuation_vector, remove_numbers, trim_token, split_string, separator, remove_stopwords, </span>
<span class="c1">#                               </span>
<span class="c1">#                                 min_num_char, stemmer, min_n_gram, max_n_gram, skip_n_gram, skip_distance, n_gram_delimiter, stemmer_ngram, stemmer_gamma, stemmer_truncate,</span>
<span class="c1">#                               </span>
<span class="c1">#                                 stemmer_batches, threads, concat_delimiter, verbose, vocabulary_path)</span>
        
        <span class="k">pass</span></div>
    
    
    
<div class="viewcode-block" id="tokenizer.transform_vec_docs"><a class="viewcode-back" href="../_autosummary/tokenizer.html#tokenizer.tokenizer.transform_vec_docs">[docs]</a>    <span class="k">def</span> <span class="nf">transform_vec_docs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_list</span><span class="p">,</span> <span class="n">as_token</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">LOCALE_UTF</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">to_lower</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">to_upper</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">language</span> <span class="o">=</span> <span class="s1">&#39;english&#39;</span><span class="p">,</span> <span class="n">REMOVE_characters</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">remove_punctuation_string</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> 
                           
                           <span class="n">remove_numbers</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">trim_token</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">split_string</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">separator</span> <span class="o">=</span> <span class="s2">&quot; </span><span class="se">\r\n\t</span><span class="s2">.,;:()?!//&quot;</span><span class="p">,</span> <span class="n">remove_punctuation_vector</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">remove_stopwords</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> 

                           <span class="n">min_num_char</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">max_num_char</span> <span class="o">=</span> <span class="n">MAX_VAL</span><span class="p">,</span> <span class="n">stemmer</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">min_n_gram</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">max_n_gram</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_gram_delimiter</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="n">skip_n_gram</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">skip_distance</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> 

			   <span class="n">vocabulary_path</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">concat_delimiter</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">path_2folder</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">threads</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        
        
       <span class="sd">&#39;&#39;&#39;     </span>
<span class="sd">        </span>
<span class="sd">        :param input_list: a character string list of documents</span>
<span class="sd">        </span>
<span class="sd">        :param as_token: if True then the method will return a list of (split) token. Otherwise it will return a list of character strings (sentences)</span>
<span class="sd">               </span>
<span class="sd">        :param LOCALE_UTF: the language specific locale to use in case that either the to_lower or the to_upper parameter is TRUE and the text file language is other than english. For instance if the language of a text file is greek then the utf_locale parameter should be &#39;el_GR.UTF-8&#39; ( language_country.encoding ). A wrong utf-locale does not raise an error, however the runtime of the method increases.</span>
<span class="sd">        </span>
<span class="sd">        :param to_lower: either True or False. If True the character string will be converted to lower case</span>
<span class="sd">        </span>
<span class="sd">        :param to_upper: either True or False. If True the character string will be converted to upper case</span>
<span class="sd">        </span>
<span class="sd">        :param language: a character string which defaults to english. If the remove_stopwords parameter is True then the corresponding stop words vector will be uploaded. Available languages &#39;afrikaans&#39;, </span>
<span class="sd">        </span>
<span class="sd">            &#39;arabic&#39;, &#39;armenian&#39;, &#39;basque&#39;, &#39;bengali&#39;, &#39;breton&#39;, &#39;bulgarian&#39;, &#39;catalan&#39;, &#39;croatian&#39;, &#39;czech&#39;,&#39;danish&#39;, &#39;dutch&#39;, &#39;english&#39;, &#39;estonian&#39;, &#39;finnish&#39;, &#39;french&#39;, &#39;galician&#39;, &#39;german&#39;, </span>
<span class="sd">            &#39;greek&#39;, &#39;hausa&#39;, &#39;hebrew&#39;, &#39;hindi&#39;, &#39;hungarian&#39;, &#39;indonesian&#39;, &#39;irish&#39;, &#39;italian&#39;, &#39;latvian&#39;, &#39;marathi&#39;, &#39;norwegian&#39;, &#39;persian&#39;, &#39;polish&#39;, &#39;portuguese&#39;, &#39;romanian&#39;, &#39;russian&#39;,</span>
<span class="sd">            &#39;slovak&#39;, &#39;slovenian&#39;, &#39;somalia&#39;, &#39;spanish&#39;, &#39;swahili&#39;, &#39;swedish&#39;, &#39;turkish&#39;, &#39;yoruba&#39;, &#39;zulu&#39;</span>

<span class="sd">        :param REMOVE_characters: a character string with specific characters that should be removed from the text file. If the remove_char is &quot;&quot; then no removal of characters take place</span>
<span class="sd">        </span>
<span class="sd">        :param remove_punctuation_string: either True or False. If True then the punctuation of the character string will be removed (applies before the split method)</span>
<span class="sd">        </span>
<span class="sd">        :param remove_numbers: either True or False. If True then any numbers in the character string will be removed</span>
<span class="sd">        </span>
<span class="sd">        :param trim_token: either True or False. If True then the string will be trimmed (left and/or right)</span>
<span class="sd">        </span>
<span class="sd">        :param split_string: either True or False. If True then the character string will be split using the separator as delimiter. The user can also specify multiple delimiters.</span>
<span class="sd">        </span>
<span class="sd">        :param separator: a character string specifying the character delimiter(s)</span>
<span class="sd">        </span>
<span class="sd">        :param remove_punctuation_vector: either True or False. If True then the punctuation of the vector of the character strings will be removed  (after the string split has taken place)</span>
<span class="sd">    </span>
<span class="sd">        :param remove_stopwords: either True, False or a character vector of user defined stop words. If True then by using the language parameter the corresponding stop words vector will be uploaded.</span>

<span class="sd">        :param min_num_char: an integer specifying the minimum number of characters to keep. If the min_num_char is greater than 1 then character strings with more than 1 characters will be returned</span>
<span class="sd">        </span>
<span class="sd">        :param max_num_char: an integer specifying the maximum number of characters to keep. The max_num_char should be less than or equal to Inf (in this method the Inf value translates to a word-length of 1000000000)</span>

<span class="sd">        :param stemmer: a character string specifying the stemming method. Available method is porter2_stemmer. </span>

<span class="sd">        :param min_n_gram: an integer specifying the minimum number of n-grams. The minimum number of min_n_gram is 1.</span>
<span class="sd">        </span>
<span class="sd">        :param max_n_gram: an integer specifying the maximum number of n-grams. The minimum number of max_n_gram is 1.</span>
<span class="sd">        </span>
<span class="sd">        :param n_gram_delimiter: a character string specifying the n-gram delimiter (applies to both n-gram and skip-n-gram cases)</span>
<span class="sd">        </span>
<span class="sd">        :param skip_n_gram: an integer specifying the number of skip-n-grams. The minimum number of skip_n_gram is 1.</span>
<span class="sd">        </span>
<span class="sd">        :param skip_distance: an integer specifying the skip distance between the words. The minimum value for the skip distance is 0, in which case simple n-grams will be returned.</span>
<span class="sd">                </span>
<span class="sd">        :param vocabulary_path_file: either None or a character string specifying the output path to a file where the vocabulary should be saved once the text is tokenized</span>
<span class="sd">        </span>
<span class="sd">        :param concat_delimiter: either None or a character string specifying the delimiter to use in order to concatenate the end-vector of character strings to a single character string (recommended in case that the end-vector should be saved to a file)</span>
<span class="sd">        </span>
<span class="sd">        :param path_2folder: a character string specifying the path to the folder where the file(s) will be saved</span>
<span class="sd">        </span>
<span class="sd">        :param threads: an integer specifying the number of cores to run in parallel</span>
<span class="sd">        </span>
<span class="sd">        :param verbose: either True or False. If True then information will be printed out</span>
<span class="sd">        </span>
<span class="sd">            Example::</span>
<span class="sd">                </span>
<span class="sd">                tok = tokenizer()</span>
<span class="sd">                </span>
<span class="sd">                res_tok = tok.transform_vec_docs(input_list = [&#39;first word sentence&#39;, &#39;second word sentence&#39;], as_token = True, to_lower = True, trim_token = True, split_string = True)</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        .. note:: It is memory efficient to read the data using a path file in case of a big file, rather than importing the data and then calling the tokenize method. </span>
<span class="sd">        </span>
<span class="sd">                  The utf_locale and split_string functionality is based on the boost library ( http://www.boost.org ). </span>
<span class="sd">                  </span>
<span class="sd">                  It is memory efficient to specify a path_2folder in case that a big file should be saved, rather than return the vector of all character strings. </span>
<span class="sd">                  </span>
<span class="sd">                  The skip-grams are a generalization of n-grams in which the components (typically words) need not to be consecutive in the text under consideration, but may leave gaps </span>
<span class="sd">                  </span>
<span class="sd">                  that are skipped over. They provide one way of overcoming the data sparsity problem found with conventional n-gram analysis. </span>
<span class="sd">                  </span>
<span class="sd">                  Stemming of the english language is done using the porter2-stemmer, for details see https://github.com/smassung/porter2_stemmer. N-gram stemming is language independent </span>
<span class="sd">                  </span>
<span class="sd">                  and supported by the following two functions:</span>
<span class="sd">                      </span>
<span class="sd">                      ngram_overlap    : The ngram_overlap stemming method is based on N-Gram Morphemes for Retrieval, Paul McNamee and James Mayfield ( http://clef.isti.cnr.it/2007/working_notes/mcnameeCLEF2007.pdf )</span>
<span class="sd">            </span>
<span class="sd">                      ngram_sequential : The ngram_sequential stemming method is a modified version based on Generation, Implementation and Appraisal of an N-gram based Stemming Algorithm, B. P. Pande, Pawan Tamta, H. S. Dhami ( https://arxiv.org/pdf/1312.4824.pdf )</span>
<span class="sd">            </span>
<span class="sd">                  The list of stop-words in all available languages was downloaded from the following link https://github.com/6/stopwords-json         </span>
<span class="sd">        </span>
<span class="sd">        &#39;&#39;&#39;</span></div>
        
        
<span class="c1">#        assert isinstance(input_list, list) and len(input_list) &gt; 1, &#39;the input_list parameter should be of type list&#39;</span>
<span class="c1">#        </span>
<span class="c1">#        assert isinstance(as_token, bool), &#39;the as_token parameter should be of type boolean&#39;</span>
<span class="c1">#        </span>
<span class="c1">#        assert isinstance(path_2folder, basestring), &#39;the path_2folder parameter should be of type string&#39;</span>
<span class="c1">#</span>
<span class="c1">#        IF UNAME_SYSNAME == &quot;Windows&quot;:</span>
<span class="c1">#            </span>
<span class="c1">#            assert path_2folder.split(&#39;\\&#39;)[-1] == &quot;&quot;, &quot;the path_2folder parameter should end in slash&quot;</span>
<span class="c1">#            </span>
<span class="c1">#        IF UNAME_SYSNAME == &quot;Darwin&quot; or UNAME_SYSNAME == &quot;Linux&quot;:</span>
<span class="c1">#            </span>
<span class="c1">#            assert path_2folder.split(&#39;/&#39;)[-1] == &quot;&quot;, &quot;the path_2folder parameter should end in slash&quot;</span>
<span class="c1">#            </span>
<span class="c1">#        assert isinstance(LOCALE_UTF, basestring), &#39;the LOCALE_UTF parameter should be of type string&#39;</span>
<span class="c1">#            </span>
<span class="c1">#        assert isinstance(to_lower, bool), &#39;the to_lower parameter should be of type boolean&#39;</span>
<span class="c1">#            </span>
<span class="c1">#        assert isinstance(to_upper, bool), &#39;the to_upper parameter should be of type boolean&#39;</span>
<span class="c1">#                </span>
<span class="c1">#        assert isinstance(REMOVE_characters, basestring), &#39;the REMOVE_characters parameter should be of type string&#39;</span>
<span class="c1">#            </span>
<span class="c1">#        assert isinstance(remove_punctuation_string, bool), &#39;the remove_punctuation_string parameter should be of type boolean&#39;</span>
<span class="c1">#            </span>
<span class="c1">#        assert isinstance(remove_numbers, bool), &#39;the remove_numbers parameter should be of type boolean&#39;</span>
<span class="c1">#            </span>
<span class="c1">#        assert isinstance(trim_token, bool), &#39;the trim_token parameter should be of type boolean&#39;</span>
<span class="c1">#            </span>
<span class="c1">#        assert isinstance(split_string, bool), &#39;the split_string parameter should be of type boolean&#39;</span>
<span class="c1">#            </span>
<span class="c1">#        assert isinstance(separator, basestring), &#39;the separator parameter should be of type string&#39;</span>
<span class="c1">#            </span>
<span class="c1">#        assert isinstance(remove_punctuation_vector, bool), &#39;the remove_punctuation_vector parameter should be of type boolean&#39;</span>
<span class="c1">#        </span>
<span class="c1">#        assert isinstance(language, basestring), &#39;the language parameter should be of type string&#39;</span>
<span class="c1">#        </span>
<span class="c1">#        assert language in [&quot;afrikaans&quot;, &quot;arabic&quot;, &quot;armenian&quot;, &quot;basque&quot;, &quot;bengali&quot;, &quot;breton&quot;, &quot;bulgarian&quot;, &quot;catalan&quot;, &quot;croatian&quot;, &quot;czech&quot;, &quot;danish&quot;, &quot;dutch&quot;, &quot;english&quot;, </span>
<span class="c1">#                            &quot;estonian&quot;, &quot;finnish&quot;, &quot;french&quot;,&quot;galician&quot;, &quot;german&quot;, &quot;greek&quot;, &quot;hausa&quot;, &quot;hebrew&quot;, &quot;hindi&quot;, &quot;hungarian&quot;, &quot;indonesian&quot;, &quot;irish&quot;, &quot;italian&quot;, </span>
<span class="c1">#                            &quot;latvian&quot;, &quot;marathi&quot;, &quot;norwegian&quot;, &quot;persian&quot;, &quot;polish&quot;, &quot;portuguese&quot;, &quot;romanian&quot;, &quot;russian&quot;, &quot;slovak&quot;, &quot;slovenian&quot;, &quot;somalia&quot;, &quot;spanish&quot;, </span>
<span class="c1">#                            &quot;swahili&quot;, &quot;swedish&quot;, &quot;turkish&quot;, &quot;yoruba&quot;, &quot;zulu&quot;], &quot;available languages in case of stop-word removal are &#39;afrikaans&#39;, &#39;arabic&#39;, &#39;armenian&#39;,\</span>
<span class="c1">#                                                                                &#39;basque&#39;, &#39;bengali&#39;, &#39;breton&#39;, &#39;bulgarian&#39;, &#39;catalan&#39;, &#39;croatian&#39;, &#39;czech&#39;,&#39;danish&#39;, &#39;dutch&#39;,\</span>
<span class="c1">#                                                                                &#39;english&#39;, &#39;estonian&#39;, &#39;finnish&#39;, &#39;french&#39;, &#39;galician&#39;, &#39;german&#39;, &#39;greek&#39;, &#39;hausa&#39;, &#39;hebrew&#39;,\</span>
<span class="c1">#                                                                                &#39;hindi&#39;, &#39;hungarian&#39;, &#39;indonesian&#39;, &#39;irish&#39;, &#39;italian&#39;, &#39;latvian&#39;, &#39;marathi&#39;, &#39;norwegian&#39;,\</span>
<span class="c1">#                                                                                &#39;persian&#39;, &#39;polish&#39;, &#39;portuguese&#39;, &#39;romanian&#39;, &#39;russian&#39;, &#39;slovak&#39;, &#39;slovenian&#39;, &#39;somalia&#39;,\</span>
<span class="c1">#                                                                                &#39;spanish&#39;, &#39;swahili&#39;, &#39;swedish&#39;, &#39;turkish&#39;, &#39;yoruba&#39;, &#39;zulu. \</span>
<span class="c1">#                                                                                \</span>
<span class="c1">#                                                                                A user defined character list of stop words can be used as input, if the target language is not included&quot;</span>
<span class="c1">#        </span>
<span class="c1">#        if isinstance(remove_stopwords, bool):</span>
<span class="c1">#            </span>
<span class="c1">#            if remove_stopwords:</span>
<span class="c1">#                </span>
<span class="c1">#                IF UNAME_SYSNAME == &quot;Windows&quot;:</span>
<span class="c1">#                    </span>
<span class="c1">#                    resource_path = &#39;\\&#39;.join((&#39;stopwords&#39;, language + &#39;.txt&#39;))</span>
<span class="c1">#                    </span>
<span class="c1">#                ELSE:</span>
<span class="c1">#                    </span>
<span class="c1">#                    resource_path = &#39;/&#39;.join((&#39;stopwords&#39;, language + &#39;.txt&#39;))</span>
<span class="c1">#                    </span>
<span class="c1">#                path_stopw = pkg_resources.resource_filename(&#39;textTinyPy&#39;, resource_path)</span>
<span class="c1">#                </span>
<span class="c1">#                dat_stopw = pd.read_csv(path_stopw, header = None)</span>
<span class="c1">#                </span>
<span class="c1">#                array_stopw = np.array(dat_stopw.as_matrix(columns=None))</span>
<span class="c1">#                </span>
<span class="c1">#                list_stopw = [i[0] for i in array_stopw]</span>
<span class="c1">#                </span>
<span class="c1">#                list_stopw.append(&quot;&quot;)</span>
<span class="c1">#                </span>
<span class="c1">#            else:</span>
<span class="c1">#                </span>
<span class="c1">#                list_stopw = []</span>
<span class="c1">#        </span>
<span class="c1">#        elif isinstance(remove_stopwords, list):</span>
<span class="c1">#            </span>
<span class="c1">#            list_stopw = remove_stopwords</span>
<span class="c1">#            </span>
<span class="c1">#            remove_stopwords = True</span>
<span class="c1">#            </span>
<span class="c1">#        else:</span>
<span class="c1">#            </span>
<span class="c1">#            raise_with_traceback(ValueError(&quot;the remove_stopwords parameter should be either a list of user defined stopwords or a logical parameter ( True or False )&quot;))</span>
<span class="c1">#            </span>
<span class="c1">#        assert isinstance(min_num_char, int) and min_num_char &gt; 0, &#39;the min_num_char parameter should be of type integer and greater than 0&#39;</span>
<span class="c1">#            </span>
<span class="c1">#        assert isinstance(max_num_char, int) and max_num_char &gt; min_num_char, &#39;the max_num_char parameter should be of type integer and greater than the min_num_char&#39;</span>
<span class="c1">#        </span>
<span class="c1">#        if max_num_char == MAX_VAL:</span>
<span class="c1">#            </span>
<span class="c1">#            max_num_char = 1000000000</span>
<span class="c1">#        </span>
<span class="c1">#        if stemmer is not None:</span>
<span class="c1">#            </span>
<span class="c1">#            assert isinstance(stemmer, basestring), &#39;the stemmer parameter should be of type string&#39;</span>
<span class="c1">#            </span>
<span class="c1">#            assert stemmer in [&quot;porter2_stemmer&quot;], &#39;available stemmer is porter2_stemmer&#39;</span>
<span class="c1">#                </span>
<span class="c1">#        if stemmer is None:</span>
<span class="c1">#            </span>
<span class="c1">#            stemmer = &quot;NULL&quot;</span>
<span class="c1">#            </span>
<span class="c1">#        assert isinstance(min_n_gram, int) and min_n_gram &gt; 0, &#39;the min_n_gram parameter should be of type integer and greater than 0&#39;</span>
<span class="c1">#        </span>
<span class="c1">#        assert isinstance(max_n_gram, int) and max_n_gram &gt; 0, &#39;the max_n_gram parameter should be of type integer and greater than 0&#39;</span>
<span class="c1">#            </span>
<span class="c1">#        assert max_n_gram &gt;= min_n_gram, &#39;the max_n_gram parameter should be greater than the min_n_gram&#39;</span>
<span class="c1">#        </span>
<span class="c1">#        assert isinstance(n_gram_delimiter, basestring), &#39;the n_gram_delimiter parameter should be of type string&#39;</span>
<span class="c1">#                  </span>
<span class="c1">#        assert isinstance(skip_n_gram, int) and skip_n_gram &gt; 0, &#39;the skip_n_gram parameter should be of type integer and greater than 0&#39;</span>
<span class="c1">#            </span>
<span class="c1">#        assert isinstance(skip_distance, int) and skip_distance &gt; -1, &#39;the skip_distance parameter should be of type integer and greater or equal to 0&#39;</span>
<span class="c1">#        </span>
<span class="c1">#        if vocabulary_path is not None:        </span>
<span class="c1">#        </span>
<span class="c1">#            assert isinstance(vocabulary_path, basestring), &#39;the vocabulary_path parameter should be of type string&#39;</span>
<span class="c1">#        </span>
<span class="c1">#        if vocabulary_path is None:</span>
<span class="c1">#            </span>
<span class="c1">#            vocabulary_path = &quot;&quot;</span>
<span class="c1">#            </span>
<span class="c1">#        if concat_delimiter is not None:</span>
<span class="c1">#            </span>
<span class="c1">#            assert isinstance(concat_delimiter, basestring), &#39;the concat_delimiter parameter should be of type string&#39;</span>
<span class="c1">#            </span>
<span class="c1">#        else:</span>
<span class="c1">#            </span>
<span class="c1">#            concat_delimiter = &quot;NULL&quot;</span>
<span class="c1">#        </span>
<span class="c1">#        assert isinstance(threads, int) and threads &gt; 0, &#39;the threads parameter should be of type integer and greater than 0&#39;</span>
<span class="c1">#            </span>
<span class="c1">#        assert isinstance(verbose, bool), &#39;the verbose parameter should be of type boolean&#39;</span>
<span class="c1">#        </span>
<span class="c1">#        </span>
<span class="c1">#        #----------</span>
<span class="c1">#        # functions        </span>
<span class="c1">#        #----------        </span>
<span class="c1">#        </span>
<span class="c1">#        cdef vector[string] result_list_string</span>
<span class="c1">#        </span>
<span class="c1">#        cdef vector[vector[string]] result_list_token        </span>
<span class="c1">#        </span>
<span class="c1">#        if as_token:</span>
<span class="c1">#            </span>
<span class="c1">#            result_list_token = self.bgf.res_token_list(input_list, list_stopw, language, LOCALE_UTF, max_num_char, REMOVE_characters, to_lower, to_upper, remove_punctuation_string, </span>
<span class="c1">#                                                 </span>
<span class="c1">#                                                        remove_punctuation_vector, remove_numbers, trim_token, split_string, separator, remove_stopwords, min_num_char, stemmer, </span>
<span class="c1">#                                                 </span>
<span class="c1">#                                                        min_n_gram, max_n_gram, skip_n_gram, skip_distance, n_gram_delimiter, concat_delimiter, path_2folder, 4, </span>
<span class="c1">#                                                 </span>
<span class="c1">#                                                        0.0, 3, 1, threads, verbose, vocabulary_path)</span>
<span class="c1">#            </span>
<span class="c1">#            return result_list_token</span>
<span class="c1">#            </span>
<span class="c1">#        else:</span>
<span class="c1">#            </span>
<span class="c1">#            result_list_string = self.bgf.res_token_vector(input_list, list_stopw, language, LOCALE_UTF, max_num_char, REMOVE_characters, to_lower, to_upper, remove_punctuation_string, </span>
<span class="c1">#                                                 </span>
<span class="c1">#                                                           remove_punctuation_vector, remove_numbers, trim_token, split_string, separator, remove_stopwords, min_num_char, stemmer, </span>
<span class="c1">#                                                 </span>
<span class="c1">#                                                           min_n_gram, max_n_gram, skip_n_gram, skip_distance, n_gram_delimiter, concat_delimiter, path_2folder, 4, </span>
<span class="c1">#                                                 </span>
<span class="c1">#                                                           0.0, 3, 1, threads, verbose, vocabulary_path)</span>
<span class="c1">#            </span>
<span class="c1">#            return result_list_string</span>
        
    <span class="k">pass</span></div>
    



                
<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">tokenizer</span><span class="p">()</span>
    <span class="n">a</span><span class="o">.</span><span class="n">transform_text</span><span class="p">(</span><span class="s1">&#39;example&#39;</span><span class="p">)</span>
    <span class="n">a</span><span class="o">.</span><span class="n">transform_vec_docs</span><span class="p">([</span><span class="s1">&#39;first word sentence&#39;</span><span class="p">,</span> <span class="s1">&#39;second word sentence&#39;</span><span class="p">])</span>
</pre></div>

           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, Lampros Mouselimis.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'0.0.1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>